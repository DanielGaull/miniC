COMMENT = _{ ("/*" ~ (!"*/" ~ ANY)* ~ "*/") | ("//" ~ (!"\n" ~ ANY)*) }
WHITESPACE = _{ " " | "\n" | "\t" | "\r" }

program = { SOI ~ topLevel* ~ EOI }

// == Top-level stuff ==
topLevel = { function | import | topLevelWithSemicolon }
topLevelWithSemicolon = _{ (varDec | typedef | struct) ~ ";" }

function = { typ ~ identifier ~ "(" ~ paramList ~ ")" ~ "{" ~ statement* ~ "}" }

struct = { "struct" ~ identifier ~ "{" ~ structInner* ~ "}" }
structInner = _{ structVarDec }
structVarDec = { typ ~ identifier ~ ";" }

typedef = { "typedef" ~ (struct | typ) ~ identifier }

import = { "#import" ~ string }

// == Core statements ==
statementWithoutSemicolon = _{ varDec | varAssign | binOpVarAssign | rreturn | expression }
statement = { statementWithoutSemicolon ~ ";" }
varAssign = { identExpr ~ "=" ~ expression }
varDec = { typ ~ identifier ~ ("=" ~ expression)? }
binOpVarAssign = { identExpr ~ arithLogicBinOp ~ "=" ~ expression }
rreturn = { "return" ~ expression }

if = { "if" ~ "(" ~ expression ~ ")" ~ "{" ~ statement* ~ "}" }
while = { "while" ~ "(" ~ expression ~ ")" ~ "{" ~ statement* ~ "}" }
doWhile = { "do" ~ "{" ~ statement* ~ "}" ~ "while" ~ "(" ~ expression ~ ")" }
for = { "for" ~ "(" ~ statement ~ expression ~ ";" ~ statementWithoutSemicolon ~ ")" ~ "{" ~ statement* ~ "}" }

// == Expressions ==
atom = { int | long | double | float | boolean | string | reference | typeCast | identifier | "(" ~ expression ~ ")" }
exprTail = { callTail | binaryOperationTail | memberAccessTail | pointerAccessTail | indexTail | "" }
expression = { atom ~ exprTail }

// This setup allows us to require that idenifiers can only start with keywords if
// there are additional characters after
keyword = _{ "return" | "struct" | "true" | "false" | "typedef" | "if" | "while" | "for" | "do" }
identifier = ${ keyword? ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

reference = ${ "&" ~ identifier }

typ = { "struct"? ~ identifier ~ "*"* }

typeCast = { "(" ~ typ ~ ")" ~ expression }

//char = @{ "'" ~ ANY ~ "'" }
int = @{ ("+" | "-")? ~ (ASCII_DIGIT)+ }
long = @{ ("+" | "-")? ~ (ASCII_DIGIT)+ ~ "L" }
double = @{ ("+" | "-")? ~ (ASCII_DIGIT)+ ~ "." ~ (ASCII_DIGIT)+ }
float = @{ ("+" | "-")? ~ (ASCII_DIGIT)+ ~ ("." ~ (ASCII_DIGIT)+)? ~ "f" }
boolean = { "true" | "false" }

string = ${ "\"" ~ strinner ~ "\"" }
strinner = @{ strchar* }
strchar = {
    !("\"" | "\\") ~ ANY
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}

// Other utils
arithLogicBinOp = { "+" | "-" | "*" | "/" | "%" | "&" | "|" | "&&" | "||" | "<<" | ">>" }
binOp = _{ arithLogicBinOp | "==" | "!=" | ">" | "<" | ">=" | "<=" }

exprList = _{ (expression ~ ",")* ~ expression? }

parameter = { typ ~ identifier }
paramList = { (parameter ~ ",")* ~ parameter }

identExpr = { identifier | ("*" ~ expression) }

// Tails
binaryOperationTail = { binOp ~ expression ~ exprTail }
indexTail = { "[" ~ expression ~ "]" ~ exprTail }
memberAccessTail = { "." ~ identifier ~ exprTail }
pointerAccessTail = { "->" ~ identifier ~ exprTail }
callTail = { "(" ~ exprList ~ ")" ~ exprTail }
