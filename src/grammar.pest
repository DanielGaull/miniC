COMMENT = _{ ("/*" ~ (!"*/" ~ ANY)* ~ "*/") | ("//" ~ (!"\n" ~ ANY)*) }
WHITESPACE = _{ " " | "\n" | "\t" | "\r" }

program = { SOI ~ topLevel* ~ EOI }

// == Top-level stuff ==
topLevel = { function | import | topLevelWithSemicolon }
topLevelWithSemicolon = _{ (varDec | typedef | struct | enum) ~ ";" }

function = { typ ~ identifier ~ "(" ~ paramList? ~ ")" ~ "{" ~ statement* ~ "}" }

struct = { "struct" ~ identifier ~ "{" ~ structInner* ~ "}" }
structInner = _{ structVarDec }
structVarDec = { typ ~ identifier ~ ";" }

typedef = { "typedef" ~ (struct | typ) ~ identifier }

import = { "#import" ~ string }

enumEntry = { identifier ~ ("=" ~ int)? }
enum = { "enum" ~ identifier ~ "{" ~ (enumEntry ~ ("," ~ enumEntry)*)? ~ "}" }

// == Core statements ==
statementWithoutSemicolon = _{ varDec | varAssign | incDec | binOpVarAssign | 
    return | emptyReturn | continue | break | expression }
bigStatement = _{ if | while | for | doWhile }
statement = { (statementWithoutSemicolon ~ ";") | bigStatement }
varAssign = { identExpr ~ "=" ~ expression }
binOpVarAssign = { identExpr ~ arithLogicBinOp ~ "=" ~ expression }
return = { "return" ~ expression }
emptyReturn = { "return" }
continue = { "continue" }
break = { "break" }

varModifier = { "long" | "short" | "signed" | "unsigned" |
    "static" | "volatile" | "extern" | "const" }
varDec = { varModifier* ~ typ ~ identifier ~ ("=" ~ expression)? }

incDecOp = { "++" | "--" }
incDec = { identExpr ~ incDecOp }

if = { "if" ~ "(" ~ expression ~ ")" ~ "{" ~ statement* ~ "}" }
while = { "while" ~ "(" ~ expression ~ ")" ~ "{" ~ statement* ~ "}" }
doWhile = { "do" ~ "{" ~ statement* ~ "}" ~ "while" ~ "(" ~ expression ~ ")" }
for = { "for" ~ "(" ~ statement ~ expression ~ ";" ~ statementWithoutSemicolon ~ ")" ~ "{" ~ statement* ~ "}" }

// == Expressions ==
atom = { int | long | double | float | boolean | string | typeCast | unaryOperation | sizeof | identifier | "(" ~ expression ~ ")" }
exprTail = { callTail | binaryOperationTail | memberAccessTail | pointerAccessTail | indexTail | "" }
expression = { atom ~ exprTail }

sizeof = { "sizeof(" ~ typ ~ ")" }

// This setup allows us to require that idenifiers can only start with keywords if
// there are additional characters after
keyword = _{ "return" | "struct" | "true" | "false" | "typedef" | "if" | "while" | "for" | "do" |
    varModifier | "continue" | "break" | "sizeof" }
identifier = ${ keyword? ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

typ = { ("struct" | "enum")? ~ identifier ~ "*"* }

typeCast = { "(" ~ typ ~ ")" ~ expression }

//char = @{ "'" ~ ANY ~ "'" }
int = @{ ("+" | "-")? ~ (ASCII_DIGIT)+ }
long = @{ ("+" | "-")? ~ (ASCII_DIGIT)+ ~ "L" }
double = @{ ("+" | "-")? ~ (ASCII_DIGIT)+ ~ "." ~ (ASCII_DIGIT)+ }
float = @{ ("+" | "-")? ~ (ASCII_DIGIT)+ ~ ("." ~ (ASCII_DIGIT)+)? ~ "f" }
boolean = { "true" | "false" }

string = ${ "\"" ~ strinner ~ "\"" }
strinner = @{ strchar* }
strchar = {
    !("\"" | "\\") ~ ANY
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}

// Other utils
arithLogicBinOp = { "+" | "-" | "*" | "/" | "%" | "&" | "|" | "^" | "&&" | "||" | "<<" | ">>" }
binOp = { "+" | "-" | "*" | "/" | "%" | "&" | "|" | "^" | "&&" | "||" | "<<" | ">>" | "==" | "!=" | ">" | "<" | ">=" | "<=" }

unaryOp = { "++" | "--" | "+" | "-" | "~" | "!" | "&" | "*" }
unaryOperation = { unaryOp ~ expression }

exprList = _{ (expression ~ ",")* ~ expression? }

parameter = { typ ~ identifier }
paramList = { (parameter ~ ",")* ~ parameter }

pointerIdent = { "*" ~ expression }
identExpr = { identifier | pointerIdent }

// Tails
binaryOperationTail = { binOp ~ expression ~ exprTail }
indexTail = { "[" ~ expression ~ "]" ~ exprTail }
memberAccessTail = { "." ~ identifier ~ exprTail }
pointerAccessTail = { "->" ~ identifier ~ exprTail }
callTail = { "(" ~ exprList ~ ")" ~ exprTail }
